\subsection{Job Assignment}

\begin{figure}[tb]
  \begin{center}
    \includegraphics[width=1.0\columnwidth]{system.pdf}
    \vspace{-2.0ex}
    \caption{System model}
    \label{fig:system}
  \end{center}
\end{figure}

A simple system configuration with 2 data centers and 2 micro
datacenters is shown in Figure~\ref{fig:system}.
When a user requests a service to a nearby service server,
the service server instantiates the requested service into a series of
micro service jobs.
The server finds the required resources for each job,
identifies the locations of the user and the required data object,
asks available resources (or their proxies) for the current costs,
and assigns the job to the node with the lowest pseudo cost.
The area for cost inquiry could be within proximity to the path
between the user and the data object.

The load of a resource can be measured in a number of ways.  Most
resources have some form of load report functions built-in.
A load value does not need to be precise, and a rough approximation is
enough for loose resource management.
On the other hand, if each allocation is not small enough both in size
and duration, the loads may not converge as expected.
That is, micro service is the enabler for this approach.

We use a simple micro job model that defines the required resources
for a micro job as $J(p, q, r, s)$ where 
$p$ is the number of micro containers, 
$q$ is frontend communication with the user, 
$r$ is backend communication with data objects (e.g., database), and
$s$ is the number of time slots.
For simplicity in the paper, we do not distinguish directions of
communications for $q$ and $r$, and assume only one user and one data
object per job.
The unit is one micro container for $p$, 1Mbps for $q$ and $r$, and 1
second for $s$.

Optionally, a job can be associated with weights for the cost
calculation with $p$, $q$, and $r$: e.g., an interactive job may raise
the weight for the frontend communication to place the job close to
the user.

To instantiate a micro job requested from a user, the system finds the
best node to allocate the required resource for $J$: $p$, $q$ and $r$
for duration $s$.

The pseudo cost $E$ to host job $j$ for a unit time at node $i$ for
user $m$ and data object $o$ is:
\begin{equation*}
	E(j, i)     = H(j,i) + G(j,i,m,o)
\end{equation*}
here, $H(j, i)$ is the computing cost to run $j$ at $i$, and
$G(j, i, m, o)$ is the communication cost to run $j$ at $i$
between $m$ and $o$.
\begin{eqnarray*}
&&  H(j,i)      = p \cdot f(\rho_{i}) \\
&&  G(j,i,m,o)  = q \cdot \smashoperator{\sum_{l \in path(m,i)}} f(\rho_{l}) + r \cdot \smashoperator{\sum_{l \in path(i,o)}} f(\rho_{l})
\end{eqnarray*}
$f(\rho)$ is the cost fuction of a resource load, and $path(m,i)$ is a set
of links from $m$ to $i$ (e.g., the shortest path weighted by cost).

To assign Job $j$, the system simply finds the lowest cost node $i$:
\begin{equation*}
	argmin_{i} \: E(j, i)
\end{equation*}

\subsection{Pseudo Cost Functions}

%% idea: mechanics model instead of optimization

Our model employs a parametric representation of pseudo cost, as a
function of load, and uses it for load control and also as
backpressure against congestion.
Micro jobs are naturally gravitated to the most cost-efficient
location.

%% model: cost function: congestion pricing combined with idle-resource pooling
The proposed model is based on congestion pricing in which the cost of
a resource dynamically changes according to the load of the resource.
It works as a barrier function for optimization; the capacity
constraint is enforced by a penelizing cost when approaching the full
capacity.

Another key idea is {\em idle-resource pooling} that tries to put resources
into idle state when possible for energy saving.
We proposed a convex cost function that enables idle-resource pooling
by modified congestion pricing.

A pseudo cost function in our model maps the load of a resource
$\rho \in [0, 1]$ to the corresponding cost.
The capacity limit is enforced by the cost function that rapidly grows
as the load approaches $1.0$, which is known as a barrier function in
optimization theory. 

We use two types of pseudo cost functions: one is the monotonic cost
function and the other is the convex cost function.
The monotonic cost function is a simple barrier function that
monotonically grows with load, up to inifinite as $\rho \to 1$.
The convex cost function is also a barrier function but also for
idle-resource pooling.
In this paper, the monotonic form is used for network links as
energy-saving-by-idling is not common for network links.

The standard forms that have the minimum cost of $1.0$ are
shown in Figure~\ref{fig:std_costfunc}. We will show how to manipulate
the standard functions in Sec.~\ref{sec:variation}.

\begin{figure}[tb]
  \begin{center}
    \includegraphics[width=1.0\columnwidth]{costfunc.pdf}
    \vspace{-2.0ex}
    \caption{Standard cost functions}
    \label{fig:std_costfunc}
  \end{center}
\end{figure}

The standard convex cost function is defined as:
\begin{equation*}
	f(\rho) = \frac{(2\rho - 1)^{2}}{1 - \rho} + 1
\end{equation*}
This function has the properties:
$min\: f(\rho) = f(.5) = 1$, and $f(0) = f(.75) = 2$.
The cost grows rapidly when $\rho \ge .75$.
The system automatically tries to keep $\rho \le .75$,
aiming at $\rho = .5$.

The standatd monotonic function is deafined as:
\begin{equation*}
	f(\rho) = \frac{\rho^{5}}{1 - \rho} + 1
\end{equation*}
to roughly match the standard convex function in $[.5, .75]$,
the working load range explained in the next subsection.

Note that the standard forms are defined just for convenience, and
other functions with a similar shape in $[0,1]$ also work for our
purposes.

\subsection{Idle-Resource Pooling in Action}

The behavior of idle-resource pooling by the convex cost function is
illustrated by the following examples in Figure~\ref{fig:4node} and
Figure~\ref{fig:4node-ratio}.

\begin{figure*}[tb]
  \begin{minipage}{1.0\columnwidth}
  \begin{center}
    \includegraphics[width=1.0\columnwidth]{4node.pdf}
    \vspace{-2.0ex}
    \caption{load distribution among 4 equivalent cost nodes}
    \label{fig:4node}
  \end{center}
  \end{minipage}
  \hspace{0.8\columnsep}
  \begin{minipage}{1.0\columnwidth}
  \begin{center}
    \includegraphics[width=1.0\columnwidth]{4node-ratio.pdf}
    \vspace{-2.0ex}
    \caption{load distribution among 4 proportional cost nodes}
    \label{fig:4node-ratio}
  \end{center}
  \end{minipage}
\end{figure*}

Assume a pool of 4 equivalent resources with the standard convex
cost function.
Also, assume that micro jobs are continuously assigned to the
system; each micro job is much smaller than the capacity of a
resource.

The initial system load $\sum \rho$ is $0$, and gradually increased up
to $3.5$ at time 350. After time 400, the system load is gradually
decreasesd back to $0$ at time 750.
Here, load $1.0$ is the capacity of a single resource. 
Initially, all resources in the pool are idle, and their costs are
all $f(0)= 2$.
First, one resource $r_{0}$ is randomly selected for allocation, and its
cost becomes lower: $f(0+) < 2$. As a result, subsequent jobs are
assigned to $r_{0}$, with lowering cost towards $\rho = .5$ and then
rising again until $\rho = .75$ where $f(.75) = 2 = f(0)$.
At this point, another resource $r_{1}$ is selected for allocation.
$r_{1}$ is preferred over $r_{0}$ as its cost becomes lower with new
allocation so that both loads move towards $\rho_{0} = \rho_{1} = .5$,
where both are balanced.
Both loads rise again until $\rho_{r_{0}} = \rho_{r_{1}} = .75$,
where the third resource $r_{2}$ kicks in.
It repeats for $r_{3}$, but no more idle resouce is available
when $\sum \rho$ reaches $3.0$ so that the loads grow beyond $.75$
up to $\sum \rho = 3.5$ with $\rho = .875$ for each.

When the system load decreases, the process is reversed.
After reaching $\rho = .5$ for all,
one resource with the lowest load $\rho < .5$ becomes more expensive
than the others.
This one is less preferred for subsequent assignments, and quickly
loses the load until it becomes idle again, while the other 3 keep
$\rho$ in $[.5, .75]$. It repeats for the remaining ones.

It is easy to see how the number of active resources changes when
there are more resources.
When the number of active resources is increasing, the load of each
active resource stay at around $\rho = .75$.
On the other hand, when the number of active resources is decreasing,
the load of each active resource stay at around $\rho = .5$.
In short, when all resources are equal, the system tries to maintain
the load of active resources in the {\em working load range}
$[.5, .75]$, while keeping idle resources as much as possible.

When resources are not equal, the behavior becomes more complex, but
the underlying mechanisms are the same.
Let's take a look at a case of 4 resources with the cost ratio $1:2:4:8$,
that is $8 f_{r_{0}} = 4 f_{r_{1}} = 2 f_{r_{2}} = f_{r_{3}}$ in
Figure~\ref{fig:4node-ratio}.
To activate $r_{1}$, the load of $r_{0}$ goes up to $.84$ to satisfy:
$f_{r_{1}}(0) = 4 = f_{r_{0}}(.84)$.
When $r_{1}$ is moving towards idle after time 550, the load
of $r_{0}$ is $.75$ to satisfy: $f_{r_{1}}(.5) = 2 = f_{r_{0}}(.75)$

For unequal resources in general, the required load to trigger new
resource allocation would be higher than $\rho = .75$ for the already
active ones to match the cost $f(0)$ for the new one, but the load
will not go much further as the slope of the cost function is steep.
Similarly, when the most expensive one among active resources becomes
idle, the load of the remaining ones stay at the matching cost at
$f(.5)$ for the deactivating one.

The system could be stabilized at local minimum (e.g., cannot activate
a resource with the minimum cost).
However, our goal is not to achieve the theoretical optimum but to
enable loose automatic distributed load balancing.

\subsection{Manipulating the Cost Function}
\label{sec:variation}

The utilization of a resource can be manipulated by modifying the cost
function of the resource.
\begin{description}
\item	[lowering or raising utilization] corresponds to raising or
	lowering the cost, e.g., to make the cost $n$ times
        more expensive, $f'(\rho) = n f(\rho)$.
        For minor adjustment, one can use an additive form,
        $f'(\rho) = f(\rho) + \Delta$.
\item	[idle-state] can be made stickier by raising the cost at
	  $\rho = 0$,
  	e.g., $f'(\rho) = n (2\rho - 1)^{2}/(1 - \rho^{n}) + 1$.
\item	[premium service] can be realized by lowering the target load so
        that a premium job are always assigned to lightly loaded resources, 
        $f'(\rho) = f(\rho + \Delta)$.
        Similary, an economy service can be made by raising the target load.
\end{description}


